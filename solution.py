from table import Table
import itertools


class Solution:
    """table - сслыка на объект - таблицу, сгенерированную автоматически
    dnf - Совершенная дизъюнктивная нормальная форма функции, заданной таблицей
    short_dnf - сокращенная дизъюнктивная нормальная форма
    table_with_pdnf?(возможно убрать) - таблица истинности, в которой первый кортеж - оценка функции(значения аргументов)
    второй кортеж - значения конюънкторов из сокращенной ДНФ, последния столбец - значения функции
    core_implicants - ядровые импликанты"""
    def __init__(self, table):
        self.table_obj = table
        self.pdnf = self.__get_pdnf()
        self.shortened_dnf = list(self.__get_shortened_dnf(self.pdnf))
        self.table_with_pdnf = self.__get_table_with_shortened_dnf()
        self.core_implicants = self.__get_core_implicants()
        self.minimal_dnf = self.__get_minimal_dnf()

    def __calc_conjunctor_value(self, args_val, conjunctor) -> int:
        """Определение значения конъюнктора по кортежу значений аргументов
        args_val - Количество переменных в таблице истинности
        conjunctor - Конъюнктор, для которого определяем значение
        """
        value = True
        # Перебираем все переменные конюъктора и вычислеем его значение
        for var in conjunctor:
            if var[0] == "!":
                uid = self.table_obj.VAR_ID[var[1]]
                value = value and not args_val[uid]
            else:
                uid = self.table_obj.VAR_ID[var]
                value = value and args_val[uid]
            if not value:
                return int(value)
        return int(value)

    def __find_arg_val_conjuctor_1(self, conjunctor) -> set:
        """Нахождения строк (значений аргументов), на которых значения конъюнкторов равны единице
        conjunctor - Конъюнктор, для которого ищем строки, где этот конъюнктор равен единице
        """
        lines = set()
        # Перебираем все строки, если конъюктор равени единице, добавляем его
        for line in self.table_obj.table:
            args_val = line[0]
            if self.__calc_conjunctor_value(args_val, conjunctor) == 1:
                lines |= {args_val}
        return lines

    def __get_core_implicants(self) -> tuple:
        """
        Получение ядровых импликантов
        Ядровые имплканты - такие конъюнкторы, что на определенном наборе аргументов, где функция равна 1 только
        этот один конюънктор равен единице, остальные, соответственно, на этом наборе аргументов равны 0
        Ядровой импликант нельзя убарть из минимальной ДНФ. Он обязательно там будет
        """
        implicants = set()
        # Перебор всех строк
        for i in range(2 ** self.table_obj.arg_cnt):
            # Если значение функции на данном наборе аргументов равно 1,
            # то ищем случай, когда всего один импликант на данной оценке равен единице
            if self.table_with_pdnf[i][2] == 1:
                conjunctor_values = self.table_with_pdnf[i][1]  # Значения конъюнкторов на определенном наборе аргументов
                cnt_of_1 = 0
                conjuctor = -1
                # Ищем строку, где всего одна единица
                for i in range(len(conjunctor_values)):
                    if conjunctor_values[i] == 1:
                        cnt_of_1 += 1
                        conjuctor = i
                # Если всего один импликант на оценке равен единице, он является ядровым
                if cnt_of_1 == 1:
                    implicants |= {self.shortened_dnf[conjuctor]}

        return tuple(implicants)

    def __get_table_with_shortened_dnf(self) -> tuple:
        """Получение таблицы истинности (в виде кортежа) с конъюнкторами из сокращенной ДНФ

        1) Результирующий кортеж состит из 2 ** self.table_obj.arg_cnt кортежей (т.е. количество строк в таблице истиности)
        2) Каждый кортеж из пункта 1) состоит из 2 кортежей: 1. значение аргументов, 2. значение конъюнкторов
        а так же, последним элементом кортежа из пункта 1) является значение функции для данных аргументов
        """
        table_with_shortened_dnf = []
        # Перебор всех строк
        for line in self.table_obj.table:
            new_line = [line[0]] # Добавление в новую строку кортежа аргументов
            conjunctor_values = []
            # Перебор конъюнкторов из сокрощенной ДНФ. Вычисление их значений
            # и последующее добавлению в новую таблицу истиности с сокращенной ДНФ
            for conjuctor in self.shortened_dnf:
                conjunctor_values += [self.__calc_conjunctor_value(line[0], conjuctor)] # Добавление значений конъюнкторов
            new_line += [tuple(conjunctor_values), line[1]] # Добавление в строку новой таблицы значения конъюнкторов и значения функции
            table_with_shortened_dnf += [tuple(new_line)] # Добовление новой строки в таблицу
        return tuple(table_with_shortened_dnf)

    @staticmethod
    def __pdnf_comparison(a, b) -> tuple:
        """Сравнение двух элементов СДНФ
        Eсли можно у них за скобки вынести общую часть,так, чтобы
        оставшиеся элементы сократились, то возвращает эту общую часть.
        a и b - кортежи символов, которые составляют элемент СДНФ,
        т.е. a и b - конъюнктор, в котором каждый аргумент записан в кортеже отдельно
        """
        common_part = [] # Общая часть двух конъюкторов
        for i in range(len(a)):
            if a[i] == b[i]:
                common_part += [a[i]]
            else:
                # Если отличие только в знаке на i-той позиции, это хорошо,
                # иначе, если отличие в самой букве, то это вообще нельзя сравнивать
                if not (a[i] == '!' + b[i] or b[i] == '!' + a[i]):
                    return ()
        if len(common_part) + 1 == len(a):
            return tuple(common_part)
        return ()

    def __get_pdnf(self) -> set:
        """Получение СДНФ по таблице истиности, являющейся свойством нашего объекта.
        СДНФ - совершенная дизъюнктивная нормальная форма. Каждый элемент этой формы
        является конъюнктором и содержит все переменные.
        """
        pdnf = set()
        # Перебор всех строк, поиск среди них таких, где значение функции равно единице
        for line in self.table_obj.table:
            if line[1] == 1:
                args = []
                # Перебор значений переменных на которых функция равна единице
                for j in range(self.table_obj.arg_cnt):
                    # Если значения аргумента равно нулю, добавляем его с отрицанием, иначе, просто добавляем его
                    if line[0][j] == 0:
                        args += [f'!{self.table_obj.VAR_NAMES[j]}']
                    else:
                        args += [f'{self.table_obj.VAR_NAMES[j]}']
                pdnf |= {tuple(args)}
        return pdnf

    def __get_shortened_dnf(self, pdnf) -> set:
        """Получение сокращенной ДНФ.
        pdnf - СДНФ для таблицы истиности, которая является свойством нашего объекта
        Максимально пытаемся винести у слагаемых аргументы за скобки, если это
        получается, в сокращенную ДНФ попадает только общая часть этих двух елементов
        """
        shrt_dnf = set()
        # Перебор всех пар элементов из СДНФ. А далее, в эту СДНФ будут добавляться элементы, это уже не будет СДНФ, однако,
        # мы будем перебирать все пары уже из нового набора до тех пор, пока что-то с чем-то может сократиться
        for i in pdnf:
            key = 0
            for j in pdnf:
                # Если элементы разные и одной длины, смотрим, можно ли их сократить
                if i != j and len(i) == len(j):
                    tpl = self.__pdnf_comparison(i, j)
                    # Если элементы сократились, то метод __pdnf_comparison вернет не пустой кортеж (кортеж из общей части)
                    if tpl:
                        # В сокращенную ДНФ добавляем общую часть
                        shrt_dnf |= {tpl}
                        key = 1
            # Если на для какого-либо объекта мы не нашли второй, с которым они могут сократиться,
            # добавляем один этот элемент в сокращенную ДНФ
            if key == 0:
                shrt_dnf |= {i}
        # Если после прохода по всем парам у нас не образовалась ни одна пара,
        # а просто все элементы добавились как отдельные, то значит, мы ничего не сократили
        # и дальше уже не может быть ничего сокращено.
        # возвращаем результат
        if shrt_dnf == pdnf:
            return shrt_dnf
        # Если же, что-то сократилось, рекурсивно вызываем этот метод от нового,
        # сокращенного набора конъюнкторов
        else:
            return self.__get_shortened_dnf(shrt_dnf)

    def __get_minimal_dnf(self) -> tuple:
        """ Поиск минимальной ДНФ, используя ядровые импликанты и таблицу истиности, в которой они есть
        1) Ядровые импликанты обязательной пойдут в минимальную ДНФ. Мы находим значения аргументов,
        на которых ядровые импликанты равны единице.
        2) Для значений функции, где ядровые импликанты не равны единице, а функция равна единице
        мы должны выбрать один (или несколько) конъюнкторов, которые бы "покрыли" эти значения функций,
        т.е. они должны быть равны единице на наборе аргументов, где функция так же равна единице.
        3) Перебором находим эти конъюнкторы, составляем все-возможные минимальные ДНФ. В них
        должно быть минимальное число слагаемых (конъюнкторов)
        """
        conjuctor_combs = []
        # Значения аргументов, на которых ядровые импликанты равны единице
        core_imps_arg_value = set()
        for i in self.core_implicants:
            core_imps_arg_value |= self.__find_arg_val_conjuctor_1(i)
        # Значения аргументов, на которых функция равна единице
        arg_value_where_func_1 = set(i[0] for i in self.table_obj.table if i[1] == 1)
        # Если ядровые импликанты покрывают значения функции (т.е. для всех строк, где функция
        # равна единице в этой строке ядровой импликант также равен единице),
        # то ядровые импликанты являются минимальной ДНФ
        if arg_value_where_func_1 == core_imps_arg_value:
            return self.core_implicants,
        # Находим все оставщиеся импликанты (не ядровые)
        not_core_imps = tuple(i for i in self.shortened_dnf if i not in self.core_implicants)
        # Перебираем число конъюнкторов, которое может дополянть ядровые до того, чтобы функция была полностью покрыта
        for i in range(len(not_core_imps), 0, -1):
            for j in itertools.combinations(not_core_imps, r=i): # Находим все комбинации не ядровых импликантов
                tmp = core_imps_arg_value.copy() # Множество нужно копировать, чтобы это не была ссылка на один и тот же объект
                # Добовляем к значениям аргументов, где ядровые импликанты равны
                # 1 значения аргументов, где не ядровые равны 1
                for k in j:
                    tmp |= self.__find_arg_val_conjuctor_1(k)
                # Если ядровые + некоторые не ядровые покрывают все 1 у функции, добавляем в ответ
                if tmp == arg_value_where_func_1:
                    conjuctor_combs += [j]
        # Ищем среди комбинаций конъюнкторов комбинации минимальной длины
        min_len = float('inf')
        for i in conjuctor_combs:
            min_len = min(len(i), min_len)
        # Проходимся по всевозможным комбинациям ядровых импликантов с не ядровыми,
        # ищем те, длина которых равна минимальной длине импликанта
        min_dnf = []
        for i in conjuctor_combs:
            if len(i) == min_len:
                min_dnf += [tuple(set(i) | set(self.core_implicants))]
        return tuple(min_dnf)
